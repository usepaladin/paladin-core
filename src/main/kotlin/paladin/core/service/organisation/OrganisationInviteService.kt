package paladin.core.service.organisation

import jakarta.transaction.Transactional
import org.springframework.security.access.AccessDeniedException
import org.springframework.stereotype.Service
import paladin.core.entities.organisation.OrganisationInviteEntity
import paladin.core.enums.organisation.OrganisationInviteStatus
import paladin.core.enums.organisation.OrganisationRoles
import paladin.core.enums.organisation.hasHigherAuthorityThan
import paladin.core.models.organisation.Organisation
import paladin.core.models.organisation.OrganisationInvite
import paladin.core.repository.organisation.OrganisationInviteRepository
import paladin.core.service.auth.AuthTokenService
import paladin.core.util.ServiceUtil.findManyResults
import paladin.core.util.ServiceUtil.findOrThrow
import java.util.*

@Service
class OrganisationInviteService(
    private val organisationService: OrganisationService,
    private val organisationInviteRepository: OrganisationInviteRepository,
    private val authTokenService: AuthTokenService
) {

    fun createOrganisationInvitation(organisationId: UUID, email: String, role: OrganisationRoles): OrganisationInvite {
        // Disallow invitation with the Owner role, ensure that this is only down through specified transfer of ownership methods
        if (role == OrganisationRoles.OWNER) {
            throw IllegalArgumentException("Cannot create an invite with the Owner role. Use transfer ownership methods instead.")
        }

        authTokenService.getUserOrganisationRoles().firstOrNull {
            it.organisationId == organisationId
        }.let {
            // An invitation can only be generated by a user who is either an owner or admin of the organisation.
            if (it == null || !it.role.hasHigherAuthorityThan(OrganisationRoles.ADMIN, inclusive = true)) {
                throw IllegalArgumentException("User does not have permission to create an invite for this organisation")
            }
        }

        // Validate organisations existence.
        val organisation: Organisation = organisationService.getOrganisation(organisationId)

        // Check if there is currently not a pending invite for this email.
        organisationInviteRepository.findByOrganisationIdAndEmailAndInviteStatus(
            organisationId = organisation.id,
            email = email,
            inviteStatus = OrganisationInviteStatus.PENDING
        ).run {
            if (this.isNotEmpty()) {
                throw IllegalArgumentException("An invitation for this email already exists.")
            }
        }

        OrganisationInviteEntity(
            organisationId = organisation.id,
            email = email,
            role = role,
            inviteStatus = OrganisationInviteStatus.PENDING,
            invitedBy = authTokenService.getUserId(),
        ).run {
            organisationInviteRepository.save(this)
            // TODO: Send out invitational email
            return OrganisationInvite.fromEntity(this)
        }
    }

    @Throws(AccessDeniedException::class, IllegalArgumentException::class)
    @Transactional
    fun handleInvitationResponse(token: String, accepted: Boolean) {
        findOrThrow(token, organisationInviteRepository::findByToken).let { invitation ->
            // Assert the user is the one who was invited
            authTokenService.getUserEmail().let {
                if (it != invitation.email) {
                    throw AccessDeniedException("User email does not match the invite email.")
                }
            }

            if (invitation.inviteStatus != OrganisationInviteStatus.PENDING) {
                throw IllegalArgumentException("Cannot decline an invitation that is not pending.")
            }

            // Handle invitation acceptance - Add user as a member of an organisation
            if (accepted) {
                invitation.apply {
                    inviteStatus = OrganisationInviteStatus.ACCEPTED
                }.run {
                    organisationInviteRepository.save(this)
                    // Add the user to the organisation as a member
                    organisationService.addMemberToOrganisation(
                        organisationId = invitation.organisationId,
                        userId = authTokenService.getUserId(),
                        role = invitation.role
                    )
                    // TODO: Send out acceptance email
                    return
                }
            }

            // Handle invitation rejection - Update the invite status to DECLINED
            invitation.apply {
                inviteStatus = OrganisationInviteStatus.DECLINED
            }.run {
                organisationInviteRepository.save(this)
                // TODO: Send out rejection email
                return
            }
        }
    }

    /**
     * Retrieves a list of invites for the current user, based off value from JWT.
     */
    fun getUserInvites(): List<OrganisationInvite> {
        authTokenService.getUserEmail().let { email ->
            findManyResults(email, organisationInviteRepository::findByEmail).run {
                return this.map { OrganisationInvite.fromEntity(it) }
            }
        }
    }

    fun getOrganisationInvites(organisationId: UUID): List<OrganisationInvite> {
        // Fetch all invites for the organisation
        return findManyResults(organisationId, organisationInviteRepository::findByOrganisationId)
            .map { OrganisationInvite.fromEntity(it) }
    }

    /**
     * Revokes an organisation invite by its ID given the invitation is still in its PENDING state.
     */
    fun revokeOrganisationInvite(id: UUID) {
        // Find the invite by ID
        findOrThrow(id, organisationInviteRepository::findById).let { invite ->
            // Ensure the invite is still pending
            if (invite.inviteStatus != OrganisationInviteStatus.PENDING) {
                throw IllegalArgumentException("Cannot revoke an invitation that is not pending.")
            }

            // Delete invitation
            organisationInviteRepository.deleteById(id)
        }
    }

}